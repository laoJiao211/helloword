# This document records daily work and other log infomation.

2019/6/25 23.24 Tuesday

.WORK_PLAN
    验证完成模块：port、stp、lldp、mirror；待验证模块：garp；未实现后台模块：mac、trunk、
    1.验证garp模块。marror也要再看一下吧。
    2.看一看添加trunk模块后台处理接口，mac部分的在之后吧。
    其他的没有了，难点还是在trunk和mac这把，本身功能做的就不好。
  
.STUDY_PLAN
    1.<8.30-8.50><Linux系统高级编程.PDF> by my phone.
    2.<12.30-13.00>看一下指针相关的知识点吧，特别是字符串数组、二位数组、函数指针，这三个记录一下，加深自己的知识点。
    3.<13.00-14.00>sleep
    4.<15.00-18.00>学习强国文章、视频学习。
    5.<18.00-20.30>根据work完成情况，未完成则继续work，完成则查看别人的md文件，或者看留言板相关的内容，发现了一个叫KindEditor的东西是js。
    6.<21.30-22.00>小崽子视频
    7.<22.30-23.00>在家记录一天的completion和summary，以及新一天plan，提交至github。
    8.<23.10-24.00>如果想玩的话，LOL和虎牙。不想玩就洗洗上床玩会儿手机。也没啥电影看。
    9.<24.00-01.00>玩或者睡觉。
    除学习任务，其他时间点可能不太会变，晚上时间可能不准，但是7必须要做，其他娱乐可自由安排一些。
    
.WORK_COMPLETION
    1.完成mirror、garp调试验证。
    2.添加了mac老化、学习、静态mac添加显示的接口，删除忘了试了。。trunk的话，没什么进展。
    代码合入了。
    
.STUDY_COMPLETION
    1.起床失败、未完成。
    2.看了，但是看时间长了自己有点翻不过来盖了，还是很基础的东西，先记下来记住。现在倒是觉得给个起始地址自己算偏移还好理解一点。。
    3.Finish
    4.Finish 43分
    5.work 没有看其他的。
    6.视频了，也打电话了。
    7.Finish
    
.SUMMARY
    1.普通一维数组的参数传递：
        栗子1：float arr[4]; 调用：func(arr); 定义：void func(float *arr);
        栗子2：float arr[4]; 调用：func(arr); 定义：void func(float arr[4]); 不常用
    2.普通二维数组的参数传递：
        栗子1：float arr[4][16]; 调用：func(arr); 定义：void func(float *arr); 需要在函数中自己计算偏移。
        栗子2：float arr[4][16]; 调用：func(arr); 定义：void func(float (*arr)[16]); arr指向有16个元素的数组，并且每个元素是float类型的。如果在函数中调用arr[2][8] <==> *(arr+(2*16+8))对就是这样。
    3.字符串二维数组的参数传递：字符串的话和普通二维数组一样。
        栗子1：char arr[4][16]; 表示数组中有4个元素，每个元素是char[16]类型的，也就是保存了16个字符的char类型，调用：func(arr); 定义：void func(char *arr); 传入首地址，自己计算偏移。
        栗子2：float arr[4][16]; 调用：func(arr); 定义：void func(char (*arr)[16]); 调用printf("%s", arr[2]); <==> printf("%s", arr+(2*16));
    4.[]的作用相当于*
    5.函数指针：定义一个函数指针：int (*pf)(int , char ); 声明函数：int func(int *, char ); 赋值：p = func; 使用：p(100, 'c');
      函数指针数组：int (*pf_arr[4])(int , char );
    RTM,这东西真是能给人搞乱掉。。。先记下来吧，记住。
    今天的话，上午不说了，以后晚上不能睡太晚了，却觉睡，而且还缺时间。。怎么办呢，是一个问题。今天的整体的任务完成还是可以的，任务不是很重，验证那些东西，在你会写了之后，接口留好，基本不会出啥问题。还是很浅显的东西，现在剩下的问题是mac地址的动态获取，之前的实现方法不好使，那就自己来维护吧，有新的mac后通知软件维护，那就需要自己写多一点代码了，而且还有mac有10多k维护起来要考虑用什么数据结构来存，之前说是树，如果还用了，就可以在学一个数据结构了，trunk模块现在来看问题有点大，首先你也不知道他是咋显示的。。。还有就是loadbalance不准的问题，mirror模块其实是可以深入做好一点的，那个感觉也不会很难。但是没时间。
    想了一下面板端口上web等报文，感觉mac表中有一个本机mac，报文目的mac为这个mac的，就转到cpu，那么第一步就是，web访问这个交换机端口ip，因为没有ip对应的mac，所以想先发arp，芯片也要把这个arp报文转给cpu，软件收到后给内核，内核处理后回复arp，pc web client收到后，开始请求web服务，这时候报文中有mac了，根据mac地址表一看，转给cpu，软件判断出是三层报文，给内核了，内核走协议栈给web server了。关键就是在arp回复这一块，还有就是vlan配ip这一个。
    先这样吧，有23.50了，好晚了，还要洗头。不要怕在总结上费时间，思考一下总是好的。多思考多总结，还有wiki不打算写了，没有啥营养，要么想想写点别的，每天复制粘贴，也不看，所以意义不太大。

        
